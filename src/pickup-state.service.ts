/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
*/
import { Injectable, signal, computed, inject } from '@angular/core';
import { PickupRequest, PickupRequestStatus, AbsenceReport, School } from '../models/app-types';
import { SupabaseService } from './supabase.service';
import { AuthService } from './auth.service';

@Injectable({ providedIn: 'root' })
export class PickupStateService {
  // Fix: Explicitly type injected service to resolve 'unknown' property errors.
  private readonly supabaseService: SupabaseService = inject(SupabaseService);
  // Fix: Explicitly type injected service to resolve 'unknown' property errors.
  private readonly authService: AuthService = inject(AuthService);

  private _allRequests = signal<PickupRequest[]>([]);
  private _absenceReports = signal<AbsenceReport[]>([]);

  readonly activeRequests = computed(() => {
    const currentUserSchoolId = this.authService.currentUserSchool()?.id;
    if (!currentUserSchoolId) return [];
    return this._allRequests().filter(req => 
      req.schoolId === currentUserSchoolId && req.status !== 'completed'
    );
  });
  
  readonly schoolAbsenceReports = computed(() => {
    const currentUserSchoolId = this.authService.currentUserSchool()?.id;
    if (!currentUserSchoolId) return [];
    return this._absenceReports().filter(report => report.schoolId === currentUserSchoolId);
  });

  constructor() {
    this.loadInitialData();
  }

  private async loadInitialData(): Promise<void> {
    // In a real application, this would fetch data from Supabase
    // For now, we'll use mock data if the user is a school admin or teacher
    if (this.authService.currentUser()?.role === 'school-admin' || this.authService.currentUser()?.role === 'teacher') {
      this._allRequests.set([]); // Clear existing if any
      this._absenceReports.set([]); // Clear existing if any
    }

    const { data: requests, error: requestsError } = await this.supabaseService.client
      .from('pickup_requests')
      .select('*')
      .order('created_at', { ascending: true });

    if (requestsError) {
      console.error('Error fetching pickup requests:', requestsError);
    } else {
      this._allRequests.set(requests as PickupRequest[]);
    }

    const { data: absences, error: absencesError } = await this.supabaseService.client
      .from('absence_reports')
      .select('*')
      .order('date', { ascending: false });

    if (absencesError) {
      console.error('Error fetching absence reports:', absencesError);
    } else {
      this._absenceReports.set(absences as AbsenceReport[]);
    }
  }

  async addRequest(request: Omit<PickupRequest, 'id'>): Promise<void> {
    // In a real app, 'id' would be generated by the database
    const newRequest = { ...request, id: crypto.randomUUID() };
    const { error } = await this.supabaseService.client
      .from('pickup_requests')
      .insert(newRequest);

    if (error) {
      console.error('Error adding pickup request:', error);
    } else {
      this._allRequests.update(requests => [...requests, newRequest]);
    }
  }

  getRequestByCode(code: string): PickupRequest | undefined {
    return this.activeRequests().find(req => req.code === code);
  }

  async updateRequestStatus(code: string, status: PickupRequestStatus): Promise<void> {
    const { error } = await this.supabaseService.client
      .from('pickup_requests')
      .update({ status })
      .eq('code', code);

    if (error) {
      console.error('Error updating request status:', error);
    } else {
      this._allRequests.update(requests => 
        requests.map(req => req.code === code ? { ...req, status } : req)
      );
    }
  }
  
  async assignPickupSpot(code: string): Promise<void> {
    const request = this.getRequestByCode(code);
    if (!request) return;

    const school = this.authService.currentUserSchool() as School | null;
    if (!school || !school.pickupZones || school.pickupZones.length === 0) {
      // If no zones configured, just mark as arrived.
      await this.updateRequestStatus(code, 'arrived');
      return;
    }

    // `activeRequests` is already computed for the current school
    const occupiedSpots = new Set(
      this.activeRequests()
        .filter(r => r.assignedSpot)
        .map(r => `${r.assignedZone}-${r.assignedSpot}`)
    );

    let assignedZone: string | undefined;
    let assignedSpot: number | undefined;

    for (const zone of school.pickupZones) {
      for (let i = 1; i <= zone.spots; i++) {
        const spotId = `${zone.name}-${i}`;
        if (!occupiedSpots.has(spotId)) {
          assignedZone = zone.name;
          assignedSpot = i;
          break;
        }
      }
      if (assignedSpot) break;
    }

    const updatePayload: { status: PickupRequestStatus; assigned_zone?: string; assigned_spot?: number } = {
      status: 'arrived'
    };
    if (assignedZone && assignedSpot) {
      updatePayload.assigned_zone = assignedZone;
      updatePayload.assigned_spot = assignedSpot;
    }

    const { error } = await this.supabaseService.client
      .from('pickup_requests')
      .update(updatePayload)
      .eq('code', code);
    
    if (error) {
      console.error('Error assigning pickup spot:', error);
    } else {
      this._allRequests.update(requests => 
        requests.map(req => {
          if (req.code === code) {
            return { 
              ...req, 
              status: 'arrived',
              assignedZone: assignedZone,
              assignedSpot: assignedSpot
            };
          }
          return req;
        })
      );
    }
  }

  async reportAbsence(report: Omit<AbsenceReport, 'id'>): Promise<void> {
    const newReport = { ...report, id: crypto.randomUUID() };
    const { error } = await this.supabaseService.client
      .from('absence_reports')
      .insert(newReport);

    if (error) {
      console.error('Error reporting absence:', error);
    } else {
      this._absenceReports.update(reports => [...reports, newReport]);
    }
  }

  async clearAllRequests(): Promise<void> {
    const { error } = await this.supabaseService.client
      .from('pickup_requests')
      .delete()
      .neq('status', 'completed'); // Only clear active/pending requests

    if (error) {
      console.error('Error clearing requests:', error);
    } else {
      this._allRequests.set(this._allRequests().filter(req => req.status === 'completed'));
    }
  }
}